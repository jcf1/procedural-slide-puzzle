{"version":3,"sources":["components/Square.jsx","components/Player.jsx","helpers/constants.js","components/Goal.jsx","components/Block.jsx","components/Board.jsx","components/PuzzleMaker.js","components/Game.jsx","index.js"],"names":["style","size","position","color","width","height","top","left","backgroundColor","border","props","Player","bounds","block","i","this","size_percent","pos","goal","blocks","direction","playerDeath","win","length","playerStop","Square","Component","Goal","Block","Board","margin","boardSize","updatePlayerPos","state","playerPos","playerDir","setState","positionCalc","blockWidth","y","x","blockSize","blockSize_percent","goalPos","handleKeyPress","bind","e","keyCode","start","blockHeight","blockWidth_percent","blockHeight_percent","map","window","onkeydown","playerInterval","setInterval","prevProps","seed","update","current","key","Position","hash","Math","seededRandom","max","rnd","round","solution","reachPositions","incomingDirections","solutionPositions","playerPositions","playerPositions_hash","blockPositions","unusedNextPositions","oppositeDirection","action","computePossibleNextPositions","puzzle","index","vertOrHori","j","next","change","temp","options","leftup","rightdown","push","currSolPositions","leftRemove","includes","has","rightRemove","splice","upRemove","downRemove","computePossibleEndPositions","get","computeReachability","prev_reachSet","prev_incomingSet","reachSet","incomingSet","set","posQueue","dirQueue","possibilities","pop","shift","repeat","addPosition","pos1","pos2","addPositions","Map","addBlock","removePosition","generatePath","startVertOrHori","tryStart","count","success","generateStartMove","generateEndMove","generateSingleMove","nextPos","directionIdx","possibleNext","isReach","testPos","addFakePosition","combined_allPositions","new_pos","pathDirection","PuzzleMaker","makePuzzle","fake","remainingStarts","fake_blocks","end","numBlocks","old_reachSet","old_incomingSet","keys","pos_hash","reachNotAll","possible","arr","split","Number","addFakeBlocks","floor","concat","getRandomSeed","random","Game","makeNewPuzzle","buttonClicked","document","getElementById","value","newSeed","reset","windowSize","updateWindowDimensions","addEventListener","removeEventListener","innerWidth","innerHeight","className","type","min","id","defaultValue","onChange","prevState","onClick","root","render","basename","process"],"mappings":"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","file":"static/js/main.688bc480.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst style = ({ size, position, color }) => {\r\n    return {\r\n        position: \"absolute\",\r\n        width: size.width + \"px\",\r\n        height: size.height + \"px\",\r\n        top: position.top + '%',\r\n        left: position.left + '%',\r\n        backgroundColor: color,\r\n        border: \"1px solid #ffffff\"\r\n    };\r\n};\r\n\r\nexport default (props) => <div style={style(props)}/>","import React, { Component } from 'react';\r\nimport Square from './Square.jsx';\r\nimport { UP,LEFT,DOWN,RIGHT } from '../helpers/constants';\r\n\r\nexport default class Player extends Component {\r\n    \r\n    // Check if going out of bounds, hit block, or reach goal\r\n    componentDidUpdate() {\r\n        let bounds;\r\n\r\n        var block;\r\n        var i;\r\n\r\n        let size = this.props.size_percent;\r\n        let pos = this.props.position;\r\n        let goal = this.props.goal;\r\n        let blocks = this.props.blocks;\r\n\r\n        switch(this.props.direction) {\r\n            case UP:\r\n                bounds = 0;\r\n                if(pos.top <= bounds) {\r\n                    this.props.playerDeath();\r\n                } else if((pos.left === goal.left) && (pos.top === (goal.top + size.height))) {\r\n                    this.props.win();\r\n                } else {\r\n                    for(i = 0; i < blocks.length; i++) {\r\n                        block = blocks[i];\r\n                        if((pos.left === block.left) && (pos.top === (block.top + size.height))) {\r\n                            this.props.playerStop()\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case LEFT:\r\n                bounds = 0;\r\n                if(pos.left <= bounds) {\r\n                    this.props.playerDeath();\r\n                } else if((pos.top === goal.top) && (pos.left === (goal.left + size.width))) {\r\n                    this.props.win();\r\n                } else {\r\n                    for(i = 0; i < blocks.length; i++) {\r\n                        block = blocks[i];\r\n                        if((pos.top === block.top) && (pos.left === (block.left + size.width))) {\r\n                            this.props.playerStop()\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case RIGHT:\r\n                bounds = 100;\r\n                if((pos.left + size.width) >= bounds) {\r\n                    this.props.playerDeath();\r\n                } else if((pos.top === goal.top) && ((pos.left + size.width) === goal.left)) {\r\n                    this.props.win();\r\n                } else {\r\n                    for(i = 0; i < blocks.length; i++) {\r\n                        block = blocks[i];\r\n                        if((pos.top === block.top) && ((pos.left + size.width) === block.left)) {\r\n                            this.props.playerStop()\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case DOWN:\r\n                bounds = 100;\r\n                if((pos.top + size.height) >= bounds) {\r\n                    this.props.playerDeath();\r\n                } else if((pos.left === goal.left) && ((pos.top + size.height) === goal.top)) {\r\n                    this.props.win();\r\n                } else {\r\n                    for(i = 0; i < blocks.length; i++) {\r\n                        block = blocks[i];\r\n                        if((pos.left === block.left) && ((pos.top + size.height) === block.top)) {\r\n                            this.props.playerStop()\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const size = this.props.size;\r\n        const top = this.props.position.top;\r\n        const left = this.props.position.left;\r\n        return (\r\n            <Square\r\n                size = {size}\r\n                position={{ top, left }}\r\n                color='blue' />\r\n        );\r\n    }\r\n}","export const UP = 'UP';\r\nexport const DOWN = 'DOWN';\r\nexport const LEFT = 'LEFT';\r\nexport const RIGHT = 'RIGHT';\r\nexport const NONE = 'NONE';\r\nexport const LOCK = 'LOCK';\r\n\r\nexport const LEFT_KEY = 37;\r\nexport const UP_KEY = 38;\r\nexport const RIGHT_KEY = 39;\r\nexport const DOWN_KEY = 40;\r\n\r\nexport const SCREEN_RATIO = 0.6;","import React, { Component } from 'react';\r\nimport Square from './Square.jsx';\r\n\r\nexport default class Goal extends Component {\r\n    render() {\r\n        //const {info: { size, top, left }} = this.props;\r\n        const size = this.props.size;\r\n        const top = this.props.position.top;\r\n        const left = this.props.position.left;\r\n        return (\r\n            <Square\r\n                size = {size}\r\n                position={{ top, left }}\r\n                color='red' />\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport Square from './Square.jsx';\r\n\r\nexport default class Block extends Component {\r\n    render() {\r\n        const size = this.props.size;\r\n        const top = this.props.position.top;\r\n        const left = this.props.position.left;\r\n        return (\r\n            <Square\r\n                size = {size}\r\n                position={{ top, left }}\r\n                color='#000000' />\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport Player from './Player';\r\nimport Goal from './Goal';\r\nimport Block from './Block';\r\nimport { UP,LEFT,DOWN,RIGHT,NONE,LOCK,UP_KEY,DOWN_KEY,LEFT_KEY,RIGHT_KEY } from '../helpers/constants';\r\n\r\nexport default class Board extends Component {\r\n\r\n  style = () => {\r\n    return {\r\n      position: \"relative\",\r\n      margin: \"1% auto\",\r\n      width: this.props.boardSize + \"px\",\r\n      height: this.props.boardSize + \"px\",\r\n      border: (this.props.boardSize/100) + \"px solid #000000\"\r\n    }\r\n  }\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      blockSize: {\r\n        width: 0,\r\n        height: 0,\r\n        border: 0\r\n      },\r\n      blockSize_percent: {\r\n        width: 0,\r\n        height: 0\r\n      },\r\n      playerPos: {top: 0, left: 0},\r\n      playerDir: LOCK,\r\n      goalPos: {top: 0, left: 0},\r\n      blocks: []\r\n    };\r\n\r\n    this.handleKeyPress = this.handleKeyPress.bind(this);\r\n    this.playerDeath = this.playerDeath.bind(this);\r\n    this.playerStop = this.playerStop.bind(this);\r\n  }\r\n\r\n  handleKeyPress(e) {\r\n    if(this.state.playerDir !== NONE) {\r\n      return;\r\n    }\r\n\r\n    let direction;\r\n    switch(e.keyCode) {\r\n        case LEFT_KEY:\r\n            // LEFT\r\n            direction = LEFT;\r\n            break;\r\n        case UP_KEY:\r\n            // UP\r\n            direction = UP;\r\n            break;\r\n        case RIGHT_KEY:\r\n            // RIGHT\r\n            direction = RIGHT;\r\n            break;\r\n        case DOWN_KEY:\r\n            // DOWN\r\n            direction = DOWN;\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n    this.setState({playerDir: direction});\r\n  }\r\n\r\n  updatePlayerPos = () => {\r\n    let pos = this.state.playerPos;\r\n    let dir = this.state.playerDir;\r\n\r\n    switch(dir) {\r\n      case LEFT:\r\n        // LEFT\r\n        pos = {top: pos.top, left: pos.left - 1};\r\n        break;\r\n      case UP:\r\n        // UP\r\n        pos = {top: pos.top - 1, left: pos.left};\r\n        break;\r\n      case RIGHT:\r\n        // RIGHT\r\n        pos = {top: pos.top, left: pos.left + 1};\r\n        break;\r\n      case DOWN:\r\n        // DOWN\r\n        pos = {top: pos.top + 1, left: pos.left};\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    this.setState({playerPos: pos});\r\n  }\r\n\r\n  positionCalc = (pos) => {\r\n    let blockWidth = 100.0/this.props.width;\r\n    let blockHeight = 100.0/this.props.height;\r\n    return ({top: blockHeight * pos.y, left: blockWidth * pos.x});\r\n  };\r\n\r\n  playerDeath() {\r\n    this.setState({\r\n      playerPos: this.positionCalc(this.props.start),\r\n      playerDir: NONE\r\n    });\r\n  }\r\n\r\n  playerStop() {\r\n    this.setState({\r\n      playerDir: NONE\r\n    });\r\n  }\r\n\r\n  win() {\r\n    this.playerDeath();\r\n  }\r\n\r\n  update() {\r\n    let blockWidth  = (((100.0/this.props.width)/100.0) * this.props.boardSize) - 2;\r\n    let blockHeight = (((100.0/this.props.height)/100.0) * this.props.boardSize) - 2;\r\n    let blockBorder = 1;\r\n\r\n    let blockWidth_percent = 100.0/this.props.width;\r\n    let blockHeight_percent = 100.0/this.props.height;\r\n\r\n    this.setState({\r\n      playerPos: this.positionCalc(this.props.start),\r\n      goalPos: this.positionCalc(this.props.goal),\r\n      blocks:  this.props.blocks.map((block,i) => this.positionCalc(block)),\r\n      playerDir: NONE,\r\n      blockSize: {\r\n        width: blockWidth,\r\n        height: blockHeight,\r\n        border: blockBorder\r\n      },\r\n      blockSize_percent: {\r\n        width: blockWidth_percent,\r\n        height: blockHeight_percent\r\n      }\r\n    });\r\n  }\r\n  \r\n  componentDidMount() {\r\n    this.setState({ playerPos: this.props.start });\r\n    window.onkeydown = this.handleKeyPress;\r\n    this.playerInterval = setInterval(this.updatePlayerPos, 15);\r\n  }\r\n  \r\n  componentDidUpdate(prevProps) {\r\n    if(this.props.seed !== prevProps.seed || (this.props.blocks.length !== prevProps.blocks.length)) {\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (      \r\n        <div>\r\n          <div>\r\n            <center><h2>Current Seed: {this.props.current}</h2></center>  \r\n          </div>\r\n          <div style={this.style()}>\r\n            < Player size={this.state.blockSize} size_percent={this.state.blockSize_percent} position={this.state.playerPos} direction={this.state.playerDir} blocks={this.state.blocks} goal={this.state.goalPos} win={this.win} playerDeath={this.playerDeath} playerStop={this.playerStop} />\r\n            < Goal size={this.state.blockSize} position={this.state.goalPos} />\r\n            {\r\n              this.state.blocks.map((block,i) => \r\n              < Block key={i} size={this.state.blockSize} position={block} />)\r\n            }\r\n          </div>\r\n        </div>\r\n    );\r\n  }\r\n}\r\n","//===================================================\r\n// Position class\r\nfunction Position(y, x) {\r\n    this.y = y;\r\n    this.x = x;\r\n    this.hash = y+\",\"+x;\r\n}\r\n//===================================================\r\n\r\n//===================================================\r\n// Random Number Generator\r\nMath.seededRandom = function(max) {\r\n    Math.seed = (Math.seed * 9301 + 49297) % 233280;\r\n    var rnd = Math.seed / 233280;\r\n    return Math.round(rnd * max);\r\n}\r\n//===================================================\r\n\r\n//===================================================\r\n// Constants\r\n\r\n// Directions\r\nconst DOWN  = 0;\r\nconst UP    = 1;\r\nconst LEFT  = 2;\r\nconst RIGHT = 3;\r\n\r\n// Puzzle Cells\r\nconst EMPTY = 0;\r\nconst START = 1;\r\nconst END   = 2;\r\nconst BLOCK = 3;\r\n\r\n// Next move is Horizontal or Vertical\r\nconst UPDOWN    = 0;\r\nconst LEFTRIGHT = 1;\r\n\r\n// Next move is Left or Right if Horizontal or Up or Down if Vertical\r\nconst LEFTUP    = 0;\r\nconst RIGHTDOWN = 1;\r\n//===================================================\r\n\r\n//===================================================\r\n// Global Variables\r\n\r\nvar solution;\r\n\r\n// ArrayList<HashMap<Position,Integer>>\r\nvar reachPositions;\r\n// ArrayList<HashMap<Position,Position>>\r\nvar incomingDirections;\r\n\r\n// ArrayList<HashSet<Position>>\r\nvar solutionPositions;\r\n// ArrayList<Position>\r\nvar playerPositions;\r\nvar playerPositions_hash;\r\n// ArrayList<Position>\r\nvar blockPositions;\r\n// ArrayList<ArrayList<LinkedList<Position>>>\r\nvar unusedNextPositions;\r\n//===================================================\r\n\r\nfunction oppositeDirection(action) {\r\n    switch(action) {\r\n        case LEFT:\r\n            return RIGHT;\r\n        case RIGHT:\r\n            return LEFT;\r\n        case UP:\r\n            return DOWN;\r\n        case DOWN:\r\n            return UP;\r\n        default:\r\n            return -1;\r\n    }\r\n}\r\n\r\nfunction computePossibleNextPositions(puzzle, height, width, index, pos, vertOrHori) {\r\n    var options = [];\r\n    var leftup = [];\r\n    var rightdown = [];\r\n\r\n    let y = pos.y;\r\n    let x = pos.x;\r\n\r\n    var i;\r\n    var j;\r\n    var next;\r\n    var block;\r\n    switch(vertOrHori) {\r\n        case UPDOWN:\r\n            for(i = y-1; i > 0; i--) {\r\n                if(puzzle[i][x] === BLOCK) {\r\n                    break;\r\n                }\r\n                leftup.push(new Position(i,x));\r\n            }\r\n\r\n            for(i = y+1; i < height-1; i++) {\r\n                if(puzzle[i][x] === BLOCK) {\r\n                    break;\r\n                }\r\n                rightdown.push(new Position(i,x));\r\n            }\r\n\r\n            var currSolPositions;\r\n            for(i = 0; i < index; i++) {\r\n                currSolPositions = solutionPositions[i];\r\n                var leftRemove = [];\r\n                for(j = 0; j < leftup.length; j++) {\r\n                    next = leftup[j];\r\n                    block = new Position(next.y - 1, next.x);\r\n                    if(playerPositions_hash.includes(next.hash) || currSolPositions.has(block.hash) || reachPositions[index-1].has(next.hash)) {\r\n                        leftRemove.push(j);\r\n                    }\r\n                }\r\n                var rightRemove = [];\r\n                for(j = 0; j < rightdown.length; j++) {\r\n                    next = rightdown[j];\r\n                    block = new Position(next.y - 1, next.x);\r\n                    if(playerPositions_hash.includes(next.hash) || currSolPositions.has(block.hash) || reachPositions[index-1].has(next.hash)) {\r\n                        rightRemove.push(j);\r\n                    }\r\n                }\r\n                for(j = 0; j < leftRemove.length; j++) {\r\n                    leftup.splice(leftRemove[j],1);\r\n                }\r\n                for(j = 0; j < rightRemove.length; j++) {\r\n                    rightdown.splice(rightRemove[j],1);\r\n                }\r\n            }\r\n            break;\r\n        case LEFTRIGHT:\r\n            for(i = x-1; i > 0; i--) {\r\n                if(puzzle[y][i] === BLOCK) {\r\n                    break;\r\n                }\r\n                leftup.push(new Position(y,i));\r\n            }\r\n\r\n            for(i = x+1; i < width-1; i++) {\r\n                if(puzzle[y][i] === BLOCK) {\r\n                    break;\r\n                }\r\n                rightdown.push(new Position(y,i));\r\n            }\r\n\r\n            for(i = 0; i < index; i++) {\r\n                currSolPositions = solutionPositions[i];\r\n                var upRemove = [];\r\n                for(j = 0; j < leftup.length; j++) {\r\n                    next = leftup[j];\r\n                    block = new Position(next.y, next.x - 1);\r\n                    if(playerPositions_hash.includes(next.hash) || currSolPositions.has(block.hash) || reachPositions[index-1].has(next.hash)) {\r\n                        upRemove.push(j);\r\n                    }\r\n                }\r\n                var downRemove = [];\r\n                for(j = 0; j < rightdown.length; j++) {\r\n                    next = rightdown[j];\r\n                    block = new Position(next.y, next.x + 1);\r\n                    if(playerPositions_hash.includes(next.hash) || currSolPositions.has(block.hash) || reachPositions[index-1].has(next.hash)) {\r\n                        downRemove.push(j);\r\n                    }\r\n                }\r\n                for(j = 0; j < upRemove.length; j++) {\r\n                    leftup.splice(upRemove[j],1);\r\n                }\r\n                for(j = 0; j < downRemove.length; j++) {\r\n                    rightdown.splice(downRemove[j],1);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    \r\n    var change;\r\n    var temp;\r\n    for(i = 0; i < leftup.length; i++) {\r\n        change = i + Math.seededRandom(leftup.length - i - 1);\r\n        temp = leftup[change];\r\n        leftup.splice(change, 1, leftup[i]);\r\n        leftup.splice(i, 1, temp);\r\n    }\r\n    for(i = 0; i < rightdown.length; i++) {\r\n        change = i + Math.seededRandom(rightdown.length - i - 1);\r\n        temp = rightdown[change];\r\n        rightdown.splice(change, 1, rightdown[i]);\r\n        rightdown.splice(i, 1, temp);\r\n    }\r\n    \r\n    options.push(leftup);\r\n    options.push(rightdown);\r\n    return options;\r\n}\r\n\r\nfunction computePossibleEndPositions(puzzle, height, width, length, index, pos, vertOrHori) {\r\n    var options = [];\r\n    var leftup = [];\r\n    var rightdown = [];\r\n\r\n    let y = pos.y;\r\n    let x = pos.x;\r\n\r\n    var i;\r\n    var next;\r\n    switch(vertOrHori) {\r\n        case UPDOWN:\r\n            for(i = y-1; i > 0; i--) {\r\n                if(puzzle[i][x] === BLOCK) {\r\n                    break;\r\n                }\r\n                next = new Position(i,x);\r\n                if(reachPositions[index].get(next.hash) === length) {\r\n                    leftup.push(next);\r\n                }\r\n            }\r\n\r\n            for(i = y+1; i < height-1; i++) {\r\n                if(puzzle[i][x] === BLOCK) {\r\n                    break;\r\n                }\r\n                next = new Position(i,x);\r\n                if(reachPositions[index].get(next.hash) === length) {\r\n                    rightdown.push(next);\r\n                }\r\n            }\r\n            break;\r\n        case LEFTRIGHT:\r\n            for(i = x-1; i > 0; i--) {\r\n                if(puzzle[y][i] === BLOCK) {\r\n                    break;\r\n                }\r\n                next = new Position(y,i);\r\n                if(reachPositions[index].get(next.hash) === length) {\r\n                    leftup.push(next);\r\n                }\r\n            }\r\n\r\n            for(i = x+1; i < width-1; i++) {\r\n                if(puzzle[y][i] === BLOCK) {\r\n                    break;\r\n                }\r\n                next = new Position(y,i);\r\n                if(reachPositions[index].get(next.hash) === length) {\r\n                    rightdown.push(next);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    \r\n    var change;\r\n    var temp;\r\n    for(i = 0; i < leftup.length; i++) {\r\n        change = i + Math.seededRandom(leftup.length - i - 1);\r\n        temp = leftup[change];\r\n        leftup.splice(change, 1, leftup[i]);\r\n        leftup.splice(i, 1, temp);\r\n    }\r\n    for(i = 0; i < rightdown.length; i++) {\r\n        change = i + Math.seededRandom(rightdown.length - i - 1);\r\n        temp = rightdown[change];\r\n        rightdown.splice(change, 1, rightdown[i]);\r\n        rightdown.splice(i, 1, temp);\r\n    }\r\n    \r\n    options.push(leftup);\r\n    options.push(rightdown);\r\n    return options;\r\n}\r\n\r\nfunction computeReachability(puzzle, height, width, prev_reachSet, prev_incomingSet, index, start, direction) {\r\n    var reachSet = prev_reachSet;\r\n    var incomingSet = prev_incomingSet;\r\n\r\n    if(direction === -1) {\r\n        reachSet.set(start.hash, 0);\r\n        incomingSet.set(start.hash, start.hash);\r\n    }\r\n\r\n    var posQueue = [];\r\n    var dirQueue = [];\r\n\r\n    var possibilities = [];\r\n    switch(direction) {\r\n        case LEFT:\r\n            possibilities.push(DOWN);\r\n            possibilities.push(UP);\r\n            break;\r\n        case RIGHT:\r\n            possibilities.push(DOWN);\r\n            possibilities.push(UP);\r\n            break;\r\n        case UP:\r\n            possibilities.push(LEFT);\r\n            possibilities.push(RIGHT);\r\n            break;\r\n        case DOWN:\r\n            possibilities.push(LEFT);\r\n            possibilities.push(RIGHT);\r\n            break;\r\n        default:\r\n            possibilities.push(DOWN);\r\n            possibilities.push(UP);\r\n            possibilities.push(LEFT);\r\n            possibilities.push(RIGHT);\r\n            break;\r\n        \r\n    }\r\n\r\n    while(possibilities.length > 0) {\r\n        posQueue.push(start);\r\n        dirQueue.push(possibilities.pop());\r\n    }\r\n\r\n    while(posQueue.length > 0 && dirQueue.length > 0) {\r\n\r\n        let pos = posQueue.shift();\r\n        let action = dirQueue.shift();\r\n        let length = reachSet.get(pos.hash) + 1;\r\n        var repeat = true;\r\n        let y = pos.y;\r\n        let x = pos.x;\r\n\r\n        var i;\r\n        var next;\r\n        switch(action) {\r\n            case LEFT:\r\n                for(i = x-1; i >= 0; i--) {\r\n                    next = new Position(y, i+1);\r\n                    if(!reachSet.has(next.hash)) {\r\n                        reachSet.set(next.hash,length);\r\n                        incomingSet.set(next.hash,pos.hash);\r\n                        repeat = false;\r\n                    }\r\n\r\n                    if((i === 0 && puzzle[y][i] === EMPTY) || (puzzle[y][i] === END)) {\r\n                        next = new Position(y, i);\r\n                        if(!reachSet.has(next.hash)) {\r\n                            reachSet.set(next.hash,length);\r\n                            incomingSet.set(next.hash,pos.hash);\r\n                        }\r\n                        break;\r\n                    } else if(puzzle[y][i] === BLOCK) {\r\n                        if(!repeat) {\r\n                            posQueue.push(next);\r\n                            dirQueue.push(UP);\r\n                            posQueue.push(next);\r\n                            dirQueue.push(DOWN);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            case RIGHT:\r\n                for(i = x+1; i < width; i++) {\r\n                    next = new Position(y, i-1);\r\n\r\n                    if(!reachSet.has(next.hash)) {\r\n                        reachSet.set(next.hash,length);\r\n                        incomingSet.set(next.hash,pos.hash);\r\n                        repeat = false;\r\n                    }\r\n\r\n                    if((i === width - 1 && puzzle[y][i] === EMPTY) || (puzzle[y][i] === END)) {\r\n                        next = new Position(y, i);\r\n                        if(!reachSet.has(next.hash)) {\r\n                            reachSet.set(next.hash,length);\r\n                            incomingSet.set(next.hash,pos.hash);\r\n                        }\r\n                        break;\r\n                    } else if(puzzle[y][i] === BLOCK) {\r\n                        if(!repeat) {\r\n                            posQueue.push(next);\r\n                            dirQueue.push(UP);\r\n                            posQueue.push(next);\r\n                            dirQueue.push(DOWN);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            case UP:\r\n                for(i = y-1; i >= 0; i--) {\r\n                    next = new Position(i+1, x);\r\n\r\n                    if(!reachSet.has(next.hash)) {\r\n                        reachSet.set(next.hash,length);\r\n                        incomingSet.set(next.hash,pos.hash);\r\n                        repeat = false;\r\n                    }\r\n\r\n                    if((i === 0 && puzzle[i][x] === EMPTY) || (puzzle[i][x] === END)) {\r\n                        next = new Position(i, x);\r\n                        if(!reachSet.has(next.hash)) {\r\n                            reachSet.set(next.hash,length);\r\n                            incomingSet.set(next.hash,pos.hash);\r\n                        }\r\n                        break;\r\n                    } else if(puzzle[i][x] === BLOCK) {\r\n                        if(!repeat) {\r\n                            posQueue.push(next);\r\n                            dirQueue.push(LEFT);\r\n                            posQueue.push(next);\r\n                            dirQueue.push(RIGHT);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            case DOWN:\r\n                for(i = y+1; i < height; i++) {\r\n                    next = new Position(i-1, x);\r\n\r\n                    if(!reachSet.has(next.hash)) {\r\n                        reachSet.set(next.hash,length);\r\n                        incomingSet.set(next.hash,pos.hash);\r\n                        repeat = false;\r\n                    }\r\n\r\n                    if((i === height - 1 && puzzle[i][x] === EMPTY) || (puzzle[i][x] === END)) {\r\n                        next = new Position(i, x);\r\n                        if(!reachSet.has(next.hash)) {\r\n                            reachSet.set(next.hash,length);\r\n                            incomingSet.set(next.hash,pos.hash);\r\n                        }\r\n                        break;\r\n                    } else if(puzzle[i][x] === BLOCK) {\r\n                        if(!repeat) {\r\n                            posQueue.push(next);\r\n                            dirQueue.push(LEFT);\r\n                            posQueue.push(next);\r\n                            dirQueue.push(RIGHT);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    reachPositions.splice(index,1,reachSet);\r\n\tincomingDirections.splice(index,1,incomingSet);\r\n}\r\n\r\nfunction addPosition(index, pos1, pos2, direction) {\r\n    let y = pos2.y;\r\n    let x = pos2.x;\r\n    var addPositions = new Map();\r\n\r\n    var i;\r\n    var pos;\r\n    switch(direction) {\r\n        case LEFT:\r\n            for(i = pos1.x; i >= x; i--) {\r\n                pos = new Position(y, i);\r\n                addPositions.set(pos.hash, pos);\r\n            }\r\n            break;\r\n        case RIGHT:\r\n            for(i = pos1.x; i <= x; i++) {\r\n                pos = new Position(y, i);\r\n                addPositions.set(pos.hash, pos);\r\n            }\r\n            break;\r\n        case UP:\r\n            for(i = pos1.y; i >= y; i--) {\r\n                pos = new Position(i, x);\r\n                addPositions.set(pos.hash, pos);\r\n            }\r\n            break;\r\n        case DOWN:\r\n            for(i = pos1.y; i <= y; i++) {\r\n                pos = new Position(i, x);\r\n                addPositions.set(pos.hash, pos);\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    solutionPositions.splice(index, 1, addPositions);\r\n}\r\n\r\nfunction addBlock(puzzle, index, pos, direction) {\r\n    let y = pos.y;\r\n    let x = pos.x;\r\n\r\n    var block;\r\n    switch(direction) {\r\n        case LEFT:\r\n            puzzle[y][x-1] = BLOCK;\r\n            block = new Position(y, x-1);\r\n            break;\r\n        case RIGHT:\r\n            puzzle[y][x+1] = BLOCK;\r\n            block = new Position(y, x+1);\r\n            break;\r\n        case UP:\r\n            puzzle[y-1][x] = BLOCK;\r\n\t\t\tblock = new Position(y-1, x);\r\n            break;\r\n        case DOWN:\r\n            puzzle[y+1][x] = BLOCK;\r\n\t\t\tblock = new Position(y+1, x);\r\n            break;\r\n        default:\r\n            block = new Position(-1,-1);\r\n            break;\r\n    }\r\n\r\n    solutionPositions[index].set(block.hash,block);\r\n    blockPositions.splice(index, 1, block);\r\n    \r\n\tlet isReach = reachPositions[index-1].has(block.hash);\r\n\r\n    return isReach;\r\n}\r\n\r\nfunction removePosition(puzzle, index) {\r\n    const pos = blockPositions[index];\r\n    const y = pos.y;\r\n    const x = pos.x;\r\n    puzzle[y][x] = EMPTY;\r\n}\r\n\r\n//===================================================\r\n// Path Generation\r\nfunction generatePath(puzzle, height, width, length) {\r\n    var startVertOrHori = Math.seededRandom(1) === 0 ? UPDOWN : LEFTRIGHT;\r\n    if(tryStart(puzzle, height, width, length, startVertOrHori)) {\r\n        return playerPositions[length];\r\n    }\r\n    startVertOrHori = startVertOrHori === UPDOWN ? LEFTRIGHT : UPDOWN;\r\n    if(tryStart(puzzle, height, width, length, startVertOrHori)) {\r\n        return playerPositions[length];\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction tryStart(puzzle, height, width, length, vertOrHori) {\r\n    let count = 0;\r\n    let max = 0;\r\n\r\n    var success = generateStartMove(puzzle, height, width, count, vertOrHori);\r\n    if(!success) {\r\n        return false;\r\n    }\r\n\r\n    while(count < (length-1)) {\r\n        if(count === (length-2)) {\r\n            success = generateEndMove(puzzle, height, width, count, length, vertOrHori);\r\n            if(success) {\r\n                return true;\r\n            }\r\n        } else {\r\n            success = generateSingleMove(puzzle, height, width, count, vertOrHori);\r\n        }\r\n        vertOrHori = vertOrHori === UPDOWN ? LEFTRIGHT : UPDOWN;\r\n        if(success) {\r\n            count += 1;\r\n        } else {\r\n            removePosition(puzzle,count);\r\n            count -= 1;\r\n        }\r\n\r\n        if(count > max) {\r\n            max = count;\r\n        }\r\n\r\n        if(count === -1 || count <= (max - 2)) {\r\n            while(count > -1) {\r\n                removePosition(puzzle,count);\r\n                count--;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction generateStartMove(puzzle, height, width, index, vertOrHori) {\r\n    let start = playerPositions[index];\r\n    computeReachability(puzzle, height, width, new Map(), new Map(), index, start, -1);\r\n    let options = computePossibleNextPositions(puzzle, height, width, index, start, vertOrHori);\r\n    unusedNextPositions[index] = options;\r\n    if((options[0].length === 0) && (options[1].length === 0)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction generateSingleMove(puzzle, height, width, index, vertOrHori) {\r\n    let current = playerPositions[index];\r\n\r\n    var direction;\r\n    var options = unusedNextPositions[index];\r\n    if(options[0].length > 0 && options[1].length > 0) {\r\n        if(Math.seededRandom(1) === 0) {\r\n            direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n        } else {\r\n            direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n        }\r\n    } else if(options[0].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n    } else if(options[1].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    vertOrHori = vertOrHori === UPDOWN ? LEFTRIGHT : UPDOWN;\r\n\tvar directionIdx = ((direction === LEFT) || (direction === UP)) ? LEFTUP : RIGHTDOWN;\r\n\tvar possibleNext = options[directionIdx];\r\n    var nextPos;\r\n    do {\r\n        if(possibleNext.length === 0) {\r\n            direction = oppositeDirection(direction);\r\n            directionIdx = directionIdx === RIGHTDOWN ? LEFTUP : RIGHTDOWN;\r\n            possibleNext = unusedNextPositions[index][directionIdx];\r\n            if(possibleNext.length === 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        nextPos = possibleNext.shift();\r\n        options = computePossibleNextPositions(puzzle, height, width, index + 1, nextPos, vertOrHori);\r\n    } while(options[0].length === 0 && options[1].length === 0);\r\n\r\n    solution.splice(index,1,direction);\r\n\r\n    addPosition(index+1, current, nextPos, direction);\r\n    let isReach = addBlock(puzzle, index+1, nextPos, direction);\r\n\r\n    unusedNextPositions.splice(index+1,1,options);\r\n    playerPositions.splice(index+1,1,nextPos);\r\n    playerPositions_hash.splice(index+1,1,nextPos.hash);\r\n\tif(!isReach) {\r\n        computeReachability(puzzle, height, width, reachPositions[index], incomingDirections[index],  index+1, nextPos, direction);\r\n\t} else {\r\n\t\tlet start = playerPositions[0];\r\n\t\tcomputeReachability(puzzle, height, width, new Map(), new Map(), index+1, start, -1);\r\n    }\r\n\treturn true;\r\n}\r\n\r\nfunction generateEndMove(puzzle, height, width, index, length, vertOrHori) {\r\n    let current = playerPositions[index];\r\n\r\n    var direction;\r\n    var options = unusedNextPositions[index];\r\n    if(options[0].length > 0 && options[1].length > 0) {\r\n        if(Math.seededRandom(1) === 0) {\r\n            direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n        } else {\r\n            direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n        }\r\n    } else if(options[0].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n    } else if(options[1].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    vertOrHori = vertOrHori === UPDOWN ? LEFTRIGHT : UPDOWN;\r\n\tvar directionIdx = ((direction === LEFT) || (direction === UP)) ? LEFTUP : RIGHTDOWN;\r\n    var possibleNext = options[directionIdx];\r\n\r\n    const start = playerPositions[0];\r\n    var nextPos;\r\n    var testPos;\r\n    do {\r\n        if(possibleNext.length === 0) {\r\n            direction = oppositeDirection(direction);\r\n            directionIdx = directionIdx === RIGHTDOWN ? LEFTUP : RIGHTDOWN;\r\n            possibleNext = unusedNextPositions[index][directionIdx];\r\n            if(possibleNext.length === 0) {\r\n                return false;\r\n            }\r\n        }\r\n        nextPos = possibleNext.shift();\r\n        switch(direction) {\r\n            case LEFT:\r\n                testPos = new Position(nextPos.y, nextPos.x - 1);\r\n                break;\r\n            case RIGHT:\r\n                testPos = new Position(nextPos.y, nextPos.x + 1);\r\n                break;\r\n            case UP:\r\n                testPos = new Position(nextPos.y - 1, nextPos.x);\r\n                break;\r\n            case DOWN:\r\n                testPos = new Position(nextPos.y + 1, nextPos.x);\r\n                break;\r\n            default:\r\n                testPos = new Position(nextPos.y, nextPos.x);\r\n                break;\r\n        }\r\n        if(!solutionPositions[index].has(testPos.hash)) {\r\n            puzzle[testPos.y][testPos.x] = BLOCK;\r\n            computeReachability(puzzle, height, width, new Map(), new Map(), index+1, start, -1);\r\n            options = computePossibleEndPositions(puzzle, height, width, length, index+1, nextPos, vertOrHori);\r\n            if(options[0].length === 0 && options[1].length === 0) {\r\n                puzzle[testPos.y][testPos.x] = EMPTY;\r\n            }\r\n        }\r\n    } while(options[0].length === 0 && options[1].length === 0);\r\n\r\n    solution.splice(index,1,direction);\r\n    addPosition(index+1, current, nextPos, direction);\r\n    addBlock(puzzle, index+1, nextPos, direction);\r\n    playerPositions.splice(index+1,1,nextPos);\r\n    playerPositions_hash.splice(index+1,1,nextPos.hash);\r\n\r\n    current = nextPos;\r\n    if(options[0].length > 0 && options[1].length > 0) {\r\n        if(Math.seededRandom(1) === 0) {\r\n            direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n            possibleNext = options[0];\r\n        } else {\r\n            direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n            possibleNext = options[1];\r\n        }\r\n    } else if(options[0].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? UP : LEFT;\r\n        possibleNext = options[0];\r\n    } else if(options[1].length > 0) {\r\n        direction = vertOrHori === UPDOWN ? DOWN : RIGHT;\r\n        possibleNext = options[1];\r\n    } else {\r\n        return false;\r\n    }\r\n    \r\n\tnextPos = possibleNext.shift();\r\n\taddPosition(index+2, current, nextPos, direction);\r\n    playerPositions.splice(index+2,1,nextPos);\r\n    playerPositions_hash.splice(index+2,1,nextPos.hash);\r\n\tsolution.splice(index+1,1,direction);\r\n\tpuzzle[nextPos.y][nextPos.x] = END;\r\n\r\n    return true;\r\n}\r\n//===================================================\r\n\r\n\r\n//===================================================\r\n// Fake Block Codes\r\nfunction addFakePosition(puzzle, combined_allPositions, pos1, pos2, action) {\r\n    const y = pos2.y;\r\n    const x = pos2.x;\r\n\r\n    let i;\r\n    let new_pos;\r\n    switch(action) {\r\n        case LEFT:\r\n            for(i = pos1.x; i >= x; i--) {\r\n                if(puzzle[y][i] === EMPTY) {\r\n                    new_pos = new Position(y, i);    \r\n                    combined_allPositions.set(new_pos.hash, new_pos);\r\n                }\r\n            }\r\n            break;\r\n        case RIGHT:\r\n            for(i = pos1.x; i <= x; i++) {\r\n                if(puzzle[y][i] === EMPTY) {\r\n                    new_pos = new Position(y, i);    \r\n                    combined_allPositions.set(new_pos.hash, new_pos);\r\n                }\r\n            }\r\n            break;\r\n        case UP:\r\n            for(i = pos1.y; i >= y; i--) {\r\n                if(puzzle[i][x] === EMPTY) {\r\n                    new_pos = new Position(i, x);    \r\n                    combined_allPositions.set(new_pos.hash, new_pos);\r\n                }\r\n            }\r\n            break;\r\n        case DOWN:\r\n            for(i = pos1.y; i <= y; i++) {\r\n                if(puzzle[i][x] === EMPTY) {\r\n                    new_pos = new Position(i, x);    \r\n                    combined_allPositions.set(new_pos.hash, new_pos);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return combined_allPositions;\r\n}\r\n\r\nfunction pathDirection(pos1, pos2) {\r\n    if(pos1.x === pos2.x) {\r\n        if(pos1.y < pos2.y) {\r\n            return DOWN;\r\n        } else if(pos1.y > pos2.y) {\r\n            return UP;\r\n        }\r\n    } else if(pos1.y === pos2.y) {\r\n        if(pos1.x < pos2.x) {\r\n            return RIGHT;\r\n        } else if(pos1.x > pos2.x) {\r\n            return LEFT;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction addFakeBlocks(puzzle, height, width, start, end, length, numBlocks) {\r\n    let fake_blocks = [];\r\n\r\n    computeReachability(puzzle, height, width, new Map(), new Map(), 0, start, -1);\r\n    let old_reachSet = reachPositions[0];\r\n    let old_incomingSet = incomingDirections[0];\r\n\r\n    for(let i = 0; i < numBlocks; i++) {\r\n        let reachSet = old_reachSet;\r\n        let incomingSet = old_incomingSet;\r\n        \r\n        let combined_allPositions = new Map();               \r\n        for(let j = 0; j < solutionPositions.length; j++) {\r\n            let map = solutionPositions[j];\r\n            for(const pos_hash of map.keys()) {\r\n                combined_allPositions.set(pos_hash,map[pos_hash]);\r\n            }\r\n        }\r\n        \r\n        let reachNotAll = new Map();\r\n        let possible = [];\r\n        for(const pos_hash of incomingSet.keys()) {\r\n            if(!combined_allPositions.has(pos_hash)) {\r\n                let arr = pos_hash.split(\",\");\r\n                let pos = new Position(Number(arr[0]),Number(arr[1]));\r\n                reachNotAll.set(pos_hash,pos);\r\n                possible.push(pos);\r\n            }\r\n        }\r\n        \r\n        let update = false;\r\n        while(possible.length !== 0 && !update) {\r\n            let pos = possible.splice(Math.seededRandom(possible.length - 1),1)[0];\r\n            let arr = incomingSet.get(pos.hash).split(\",\");\r\n            let pos2 = new Position(Number(arr[0]),Number(arr[1]));\r\n            let action = pathDirection(pos2,pos);\r\n\r\n            let block;\r\n\r\n            const y = pos.y;\r\n            const x = pos.x;\r\n            switch(action) {\r\n                case LEFT:\r\n                    if((x - 1) < 0) {\r\n                        continue;\r\n                    }\r\n                    block = new Position(y, x-1);\r\n                    break;\r\n                case RIGHT:\r\n                    if((x + 1) >= width) {\r\n                        continue;\r\n                    }\r\n                    block = new Position(y, x+1);\r\n                    break;\r\n                case UP:\r\n                    if((y - 1) < 0) {\r\n                        continue;\r\n                    }\r\n                    block = new Position(y-1, x);\r\n                    break;\r\n                case DOWN:\r\n                    if((x + 1) < height) {\r\n                        continue;\r\n                    }\r\n                    block = new Position(y+1, x);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n            if(combined_allPositions.has(block) || puzzle[block.y][block.x] !== EMPTY || puzzle[pos.y][pos.x] !== EMPTY) {\r\n                continue;\r\n            }\r\n\r\n            puzzle[block.y][block.x] = BLOCK;\r\n            computeReachability(puzzle, height, width, new Map(), new Map(), 0, start, -1);\r\n            reachSet = reachPositions[0];\r\n            incomingSet = incomingDirections[0];\r\n\r\n            if(reachSet.get(end.hash) === length) {\r\n                update = true;\r\n                fake_blocks.push(block);\r\n                combined_allPositions = addFakePosition(puzzle, combined_allPositions,  pos, old_incomingSet.get(pos.hash), action);\r\n                old_reachSet = reachSet;\r\n                old_incomingSet = incomingSet;\r\n            } else {\r\n                puzzle[block.y][block.x] = EMPTY;\r\n                reachSet = old_reachSet;\r\n                incomingSet = old_incomingSet;\r\n            }\r\n        }\r\n        if(possible.length === 0) {\r\n            return fake_blocks;\r\n        }\r\n    }\r\n    return fake_blocks;\r\n}\r\n//===================================================\r\n\r\nfunction makePuzzle(seed, fake, width, height) {\r\n    // Seed Random Generator\r\n    Math.seed = seed;\r\n\r\n    // Set Length of Solution\r\n    let length;\r\n    if(width >= height) {\r\n        length = ((height * 3) / 4) + Math.seededRandom(height / 2);\r\n    } else {\r\n        length = ((width * 3) / 4) + Math.seededRandom(width / 2);\r\n    }\r\n\r\n    // Initialize Puzzle Array\r\n    var puzzle = [];\r\n    for(var i = 0; i < height; i++) {\r\n        puzzle[i] = [];\r\n        for(var j = 0; j < width; j++) {\r\n            puzzle[i].push(0);\r\n        }\r\n    }\r\n\r\n    var remainingStarts = [];\r\n    for(var y = 0; y < height; y++) {\r\n        for(var x = 0; x < width; x++) {\r\n            remainingStarts.push(new Position(y, x));\r\n        }\r\n    }\r\n\r\n    var start = new Position(0,0);\r\n    var goal;\r\n    do {\r\n        // Initialize global Structures\r\n        solution = [];\r\n        solutionPositions = [];\r\n        playerPositions = [];\r\n        playerPositions_hash = [];\r\n        blockPositions = [];\r\n        reachPositions = [];\r\n        incomingDirections = [];\r\n        unusedNextPositions = [];\r\n\r\n        for(i = 0; i < length; i++) {\r\n            solution.push(-1);\r\n            solutionPositions.push(new Map());\r\n            playerPositions.push(new Position(-1,-1));\r\n            playerPositions_hash.push(\"-1,-1\");\r\n            blockPositions.push(new Position(-1,-1));\r\n            reachPositions.push(new Map());\r\n            incomingDirections.push(new Map());\r\n            unusedNextPositions.push([]);\r\n        }\r\n\r\n        start = remainingStarts.splice(Math.seededRandom(remainingStarts.length - 1), 1)[0];\r\n        puzzle[start.y][start.x] = START;\r\n\r\n        solutionPositions[0].set(start.hash, start);\r\n        playerPositions.splice(0,1,start);\r\n        playerPositions_hash.splice(0,1,start.hash);\r\n        blockPositions.splice(0,1,start);\r\n\r\n        goal = generatePath(puzzle, height, width, length);\r\n    } while (goal == null &&  remainingStarts.length > 0);\r\n\r\n    if(goal == null) {\r\n        return null;\r\n    }\r\n\r\n    //Remove Start Position from Block Positions\r\n    blockPositions.splice(0,1);\r\n    \r\n    // Add Fake Blocks Here if \"fake\" is true\r\n    if(fake) {\r\n        let numBlocks = Math.floor(length / 2) + Math.seededRandom(Math.floor(length / 4));\r\n        let fake_blocks = addFakeBlocks(puzzle, height, width, start, goal, length, numBlocks)\r\n        blockPositions = blockPositions.concat(fake_blocks);\r\n    }\r\n    \r\n\r\n    return {\r\n        start: start,\r\n        goal: goal,\r\n        blocks: blockPositions\r\n    }\r\n}\r\n\r\nvar PuzzleMaker = {\r\n    makePuzzle\r\n}\r\n\r\n//module.exports = PuzzleMaker;\r\nexport default PuzzleMaker;","import React, { Component } from 'react';\r\nimport Board from './Board';\r\nimport PuzzleMaker from './PuzzleMaker.js';\r\nimport { SCREEN_RATIO } from '../helpers/constants';\r\n\r\nconst getRandomSeed = () => {\r\n    return Math.floor(Math.random() * 1000000000);\r\n}\r\n\r\nexport default class Game extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            windowSize: {\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            start: {y: 0, x: 0},\r\n            goal: {y: 0, x: 0},\r\n            blocks: [],\r\n            seed: -1,\r\n            current: -1,\r\n            width: 20,\r\n            height: 20,\r\n            fake: false\r\n        }\r\n\r\n        this.buttonClicked = this.buttonClicked.bind(this);\r\n        this.updateWindowDimensions = this.updateWindowDimensions.bind(this);\r\n    }\r\n\r\n    makeNewPuzzle = (seed) => {\r\n        this.setState({current:seed});\r\n        //Call Puzzle Generation\r\n        let puzzle = PuzzleMaker.makePuzzle(seed, this.state.fake, this.state.width, this.state.height);\r\n        this.setState({start: puzzle.start, goal: puzzle.goal, blocks: puzzle.blocks});\r\n    }\r\n\r\n    buttonClicked = () => {\r\n        let seed = document.getElementById(\"seed-box\").value;\r\n        if(seed < 0 || seed > 1000000000) {\r\n            seed = getRandomSeed();;\r\n            document.getElementById(\"seed-box\").value = seed;\r\n        } \r\n        this.setState({seed: seed});\r\n        this.makeNewPuzzle(seed);\r\n    }\r\n\r\n    newSeed = () => {\r\n        let seed = getRandomSeed();\r\n        this.setState({seed: seed});\r\n        document.getElementById(\"seed-box\").value = seed;\r\n    }\r\n\r\n    reset = () => {\r\n        let seed = getRandomSeed();\r\n        this.setState({seed: seed});\r\n        document.getElementById(\"seed-box\").value = seed;\r\n        this.makeNewPuzzle(seed);\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.buttonClicked();\r\n        this.updateWindowDimensions();\r\n        window.addEventListener(\"resize\", this.updateWindowDimensions.bind(this));\r\n    }\r\n    \r\n      componentWillUnmount() {\r\n        window.removeEventListener(\"resize\", this.updateWindowDimensions.bind(this));\r\n      }\r\n    \r\n      updateWindowDimensions() {\r\n        this.setState({ windowSize : { width: window.innerWidth, height: window.innerHeight } });\r\n      }\r\n    \r\n    render() {\r\n        return (\r\n            <div className=\"game-options\">\r\n                <div>\r\n                    <label>Random Seed:</label>\r\n                    <input type=\"number\" min=\"0\" id=\"seed-box\" defaultValue={getRandomSeed()} />\r\n                </div>\r\n                <div>\r\n                    <label>Add Fake Blocks:</label>\r\n                    <input id=\"fake-box\" type=\"checkbox\" onChange={(e) => this.setState(prevState => ({fake: !prevState.fake})) } />\r\n                </div>\r\n                <div>\r\n                    <button onClick={this.buttonClicked.bind(this)}>Make Puzzle</button>\r\n                </div>\r\n                <div>\r\n                    <button onClick={this.newSeed.bind(this)}>Random Seed</button>\r\n                </div>\r\n                <div>\r\n                    < Board seed={this.state.seed} boardSize={(this.state.windowSize.width > this.state.windowSize.height ? this.state.windowSize.height : this.state.windowSize.width) * SCREEN_RATIO} current={this.state.current} width={this.state.width} height={this.state.height} start={this.state.start} goal={this.state.goal} blocks={this.state.blocks} reset={this.reset.bind(this)} />\r\n                </div>\r\n                <div style={{margin:\"0 auto\", width : (this.state.windowSize.width * 0.75)+\"px\"}}>\r\n                    <div><b>OBJECTIVE:</b>&emsp;Use the arrow keys to move the blue block to the red block by sliding and colliding with the black blocks. If you slide off the board, you will be put back into the starting position.</div>\r\n                    <div><b>OPTIONS:</b>&emsp;&emsp; Change the level by changing the \"Random Seed\" value above and clickint the \"Make Puzzle\" button. The \"Random Seed\" button will generate a new \"Random Seed\" for you. Setting the \"Fake Blocks\" option will add blocks that are not required for the level's solution to the board.</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\r\nimport { render } from 'react-dom';\r\nimport { HashRouter } from \"react-router-dom\";\r\nimport Game from './components/Game.jsx';\r\n\r\nconst root = document.getElementById('root');\r\n\r\nrender(\r\n  <div>\r\n    <HashRouter basename={process.env.PUBLIC_URL}>\r\n      <div>\r\n        <header>\r\n          <h1>Procedural Slide Puzzles</h1>\r\n        </header>\r\n      </div>\r\n      <Game/>\r\n    </HashRouter>\r\n  </div>\r\n, root);\r\n"],"sourceRoot":""}